{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "terminable",
  "type": "registry:component",
  "dependencies": [
    "sonner"
  ],
  "registryDependencies": [
    "menubar"
  ],
  "files": [
    {
      "path": "registry/components/ui/Terminable.tsx",
      "content": "\"use client\";\nimport { useState, useEffect, useRef, useCallback, useMemo } from \"react\";\nimport {\n  Menubar,\n  MenubarMenu,\n  MenubarTrigger,\n  MenubarContent,\n} from \"~/components/ui/menubar\";\nimport { toast } from \"sonner\";\n\nexport type OutputContent = {\n  delay?: number;\n  placeholder?: string | React.ReactNode;\n  content: string | React.ReactNode;\n};\n\nexport type DisplayEntry = {\n  type: \"command\" | \"output\";\n  content: string | React.ReactNode;\n  done?: boolean;\n}\n\nexport type CommandEntry = {\n  prompt: string | React.ReactNode;\n  output?: string | OutputContent | React.ReactNode | Array<string | OutputContent | React.ReactNode>;\n  typingSpeed?: number;\n  typingRandom?: number;\n  delay?: number;\n  outputDelay?: number;\n  onDone?: () => void;\n  onCopy?: () => void;\n  onBeforeOutput?: () => void;\n}\n\nexport type TerminableProps = {\n  commands: CommandEntry[];\n  defaultTypingSpeed?: number;\n  defaultTypingRandom?: number;\n  defaultOutputSpeed?: number;\n  width?: string; // Tailwind width class\n  height?: string; // Tailwind height class\n  termPrompt?: string | React.ReactNode;\n  startLine?: string | React.ReactNode;\n  backgroundColor?: string; // Tailwind or custom color\n  promptColor?: string; // Tailwind or custom color\n  outputColor?: string; // Tailwind or custom color\n  greenMenu?: React.ReactNode;\n  yellowMenu?: React.ReactNode;\n  redMenu?: React.ReactNode;\n  title?: string | React.ReactNode;\n  commandDelay?: number; // New prop for delay between commands\n  allowCopy?: boolean; // New prop to control copy functionality\n  start?: boolean;\n}\n\n// Add new types for refs\ntype CommandProcessingState = {\n  isProcessing: boolean;\n  currentIndex: number;\n};\n\nexport default function Terminable({\n  commands = [],\n  defaultTypingSpeed = 50,\n  defaultOutputSpeed = 30,\n  width = \"w-full max-w-[800px]\",\n  height = \"min-h-[300px] max-h-[500px]\",\n  termPrompt = \"$ \",\n  startLine = \"\",\n  backgroundColor = \"bg-[#1a1a1a]\",\n  promptColor = \"text-[#00ff00]\",\n  outputColor = \"text-white\",\n  greenMenu,\n  yellowMenu,\n  redMenu,\n  title,\n  commandDelay = 1000,\n  allowCopy = true,\n  start = true,\n}: TerminableProps) {\n  const [display, setDisplay] = useState<DisplayEntry[]>([\n    { type: \"output\", content: startLine },\n  ]);\n\n  // Remove the isProcessing state and rely only on processingStateRef\n  const processingStateRef = useRef<CommandProcessingState>({\n    isProcessing: false,\n    currentIndex: 0,\n  });\n\n  const terminalRef = useRef<HTMLDivElement>(null);\n  const userScrolledRef = useRef<boolean>(false);\n\n  // Calculate typing delay with useMemo\n  const calculateTypingDelay = useMemo(() => {\n    return (baseSpeed: number, randomFactor: number = 0) => {\n      const randomVariation = Math.random() * (baseSpeed * (randomFactor / 100));\n      return Math.max(10, baseSpeed + (Math.random() > 0.5 ? randomVariation : -randomVariation));\n    };\n  }, []);\n\n  // Auto-scroll logic\n  useEffect(() => {\n    if (terminalRef.current && !userScrolledRef.current) {\n      terminalRef.current.scrollTop = terminalRef.current.scrollHeight;\n    }\n  }, [display]);\n\n  const handleScroll = useCallback(() => {\n    if (!terminalRef.current) return;\n\n    const { scrollTop, scrollHeight, clientHeight } = terminalRef.current;\n    const isScrolledToBottom = scrollHeight - scrollTop === clientHeight;\n\n    if (!isScrolledToBottom) {\n      userScrolledRef.current = true;\n    } else {\n      userScrolledRef.current = false;\n    }\n  }, []);\n\n  // Separate command processing logic\n  const processCommandOutput = useCallback(\n    async (\n      output: string | React.ReactNode | OutputContent | Array<string | React.ReactNode | OutputContent>,\n      defaultSpeed: number,\n      onBeforeOutput?: () => void,\n    ) => {\n      const outputs = Array.isArray(output) ? output : [output];\n\n      for (const line of outputs) {\n        if (!line) continue;\n\n        await new Promise((resolve) => setTimeout(resolve, defaultSpeed));\n\n        // Handle ReactNode directly\n        if (typeof line !== 'string' && !(line && typeof line === 'object' && 'content' in line)) {\n          onBeforeOutput?.();\n          setDisplay((prev) => [...prev, { type: \"output\", content: line }]);\n          continue;\n        }\n\n        if (typeof line === \"string\") {\n          onBeforeOutput?.();\n          setDisplay((prev) => [...prev, { type: \"output\", content: line }]);\n          continue;\n        }\n\n        // Handle OutputContent\n        onBeforeOutput?.();\n        setDisplay((prev) => [\n          ...prev,\n          { type: \"output\", content: line.placeholder ?? \"\" },\n        ]);\n\n        if (line.delay) {\n          await new Promise((resolve) => setTimeout(resolve, line.delay));\n        }\n\n        setDisplay((prev) => {\n          const newDisplay = [...prev];\n          const lastEntry = newDisplay[newDisplay.length - 1];\n          if (lastEntry?.type === \"output\") {\n            lastEntry.content = line.content;\n          }\n          return newDisplay;\n        });\n      }\n    },\n    [],\n  );\n\n  const processCommand = useCallback(\n    async (cmd: CommandEntry) => {\n      if (processingStateRef.current.isProcessing) return;\n      \n      try {\n        processingStateRef.current.isProcessing = true;\n        \n        if (processingStateRef.current.currentIndex > 0) {\n          await new Promise((resolve) => setTimeout(resolve, cmd.delay ?? commandDelay));\n        }\n\n        // Add command prompt\n        setDisplay((prev) => [...prev, { type: \"command\", content: \"\", done: false }]);\n\n        // Handle ReactNode prompt\n        if (typeof cmd.prompt !== \"string\") {\n          setDisplay((prev) => {\n            const lastEntry = prev[prev.length - 1];\n            if (lastEntry?.type === \"command\") {\n              return [...prev.slice(0, -1), { ...lastEntry, content: cmd.prompt, done: true }];\n            }\n            return prev;\n          });\n        } else {\n          // Type the command\n          const trimmedPrompt = cmd.prompt.trim();\n          let currentContent = \"\";\n          \n          for (const char of trimmedPrompt) {\n            const delay = calculateTypingDelay(\n              cmd.typingSpeed ?? defaultTypingSpeed,\n              cmd.typingRandom\n            );\n            \n            await new Promise((resolve) => setTimeout(resolve, delay));\n            currentContent += char;\n            \n            setDisplay((prev) => {\n              const lastEntry = prev[prev.length - 1];\n              if (lastEntry?.type === \"command\") {\n                return [...prev.slice(0, -1), { ...lastEntry, content: currentContent }];\n              }\n              return prev;\n            });\n          }\n\n          // Mark command as done\n          setDisplay((prev) => {\n            const lastEntry = prev[prev.length - 1];\n            if (lastEntry?.type === \"command\") {\n              return [...prev.slice(0, -1), { ...lastEntry, done: true }];\n            }\n            return prev;\n          });\n        }\n\n        // Process outputs\n        if (cmd.output) {\n          if (cmd.outputDelay) {\n            await new Promise((resolve) => setTimeout(resolve, cmd.outputDelay));\n          }\n          await processCommandOutput(cmd.output, defaultOutputSpeed, cmd.onBeforeOutput);\n        }\n\n        cmd.onDone?.();\n        processingStateRef.current.currentIndex += 1;\n      } catch (error) {\n        console.error('Error processing command:', error);\n        toast.error(error instanceof Error ? error.message : 'Unknown error', { duration: 3000 });\n      } finally {\n        processingStateRef.current.isProcessing = false;\n      }\n    },\n    [commandDelay, defaultOutputSpeed, defaultTypingSpeed, calculateTypingDelay, processCommandOutput]\n  );\n\n  useEffect(() => {\n    if (start) {\n      const processCommands = async () => {\n        try {\n          while (processingStateRef.current.currentIndex < commands.length) {\n            const cmd = commands[processingStateRef.current.currentIndex];\n            if (cmd) {\n              await processCommand(cmd);\n            } else {\n              processingStateRef.current.currentIndex++;\n            }\n          }\n        } catch (error) {\n          console.error('Error processing commands:', error);\n          toast.error(`Error processing commands: ${error instanceof Error ? error.message : 'Unknown error'}`, { duration: 2000 });\n        }\n      };\n      void processCommands();\n    }\n    \n    return () => {\n      processingStateRef.current.isProcessing = false;\n    };\n  }, [start, commands, processCommand]);\n\n  return (\n    <div\n      className={`mx-auto my-1 ${width} overflow-hidden rounded-lg ${backgroundColor} font-mono`}\n    >\n      <div className=\"flex items-center bg-[#333] px-2\">\n        <Menubar className=\"border-none bg-transparent shadow-none\">\n          <MenubarMenu>\n            <MenubarTrigger className=\"p-0 hover:bg-transparent\">\n              <div className=\"h-3 w-3 rounded-full bg-[#27c93f]\" />\n            </MenubarTrigger>\n            <MenubarContent>{greenMenu && greenMenu}</MenubarContent>\n          </MenubarMenu>\n          <MenubarMenu>\n            <MenubarTrigger className=\"p-0 hover:bg-transparent\">\n              <div className=\"h-3 w-3 rounded-full bg-[#ffbd2e]\" />\n            </MenubarTrigger>\n            <MenubarContent>{yellowMenu && yellowMenu}</MenubarContent>\n          </MenubarMenu>\n          <MenubarMenu>\n            <MenubarTrigger className=\"p-0 hover:bg-transparent\">\n              <div className=\"h-3 w-3 rounded-full bg-[#ff5f56]\" />\n            </MenubarTrigger>\n            <MenubarContent>{redMenu && redMenu}</MenubarContent>\n          </MenubarMenu>{\" \"}\n        </Menubar>\n        <div className=\"flex-1 text-center text-sm\">\n          {title}\n        </div>\n      </div>\n      <div\n        ref={terminalRef}\n        onScroll={handleScroll}\n        className={`${height} overflow-y-auto p-5 ${promptColor} whitespace-pre-wrap break-words`}\n        role=\"log\"\n        aria-live=\"polite\"\n      >\n        {display.map((entry, index) => (\n          <div key={`${index}-${entry.type}`} className=\"my-1\">\n            {entry.type === \"command\" && (\n              <div className=\"flex\">\n                <span className={`mr-2 ${promptColor}`}>{termPrompt}</span>\n                <span\n                  className={`${!entry.done ? \"animate-blink border-r-2 border-[#00ff00]\" : \"\"} cursor-pointer break-all rounded px-1 hover:bg-[#333]`}\n                  onClick={() => {\n                    const cmd = commands[processingStateRef.current.currentIndex];\n                    if (allowCopy && entry.done && typeof entry.content === \"string\" && cmd) {\n                      cmd.onCopy?.();\n                      navigator.clipboard.writeText(entry.content).then(() => {\n                        toast.success(\"Copied to clipboard\", {\n                          duration: 1000,\n                        });\n                      }).catch((error) => {\n                        console.error(\"Failed to copy to clipboard:\", error);\n                        toast.error(\"Failed to copy to clipboard\", {\n                          duration: 1000,\n                        });\n                      });\n                    }\n                  }}\n                >\n                  {entry.content}\n                </span>\n              </div>\n            )}\n            {entry.type === \"output\" && (\n              <div\n                key={`${index}__`}\n                className={`ml-6 whitespace-pre-wrap break-all ${outputColor}`}\n              >\n                {entry.content}\n              </div>\n            )}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n} ",
      "type": "registry:component"
    }
  ]
}